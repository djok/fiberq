---
phase: 04-dashboard-analytics
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/db/init.sql
  - server/api/projects/models.py
  - server/api/projects/routes.py
autonomous: true

must_haves:
  truths:
    - "GET /projects/{id}/stats returns element counts, team size, and last sync timestamp in a single response"
    - "GET /projects/{id}/activity returns paginated activity entries in reverse chronological order"
    - "Stats return null for count metrics when no infrastructure data exists (no sync_log entry), not 0"
    - "Status changes and member removals are recorded in project_activity_log for future feed queries"
    - "Activity feed combines sync uploads, member assignments, and status changes via UNION ALL"
  artifacts:
    - path: "server/db/init.sql"
      provides: "project_activity_log table definition"
      contains: "project_activity_log"
    - path: "server/api/projects/models.py"
      provides: "ProjectStats and ActivityEntry Pydantic models"
      contains: "ProjectStats"
    - path: "server/api/projects/routes.py"
      provides: "GET /stats and GET /activity endpoints, activity logging in update/assign/remove"
      exports: ["get_project_stats", "get_project_activity"]
  key_links:
    - from: "server/api/projects/routes.py"
      to: "project_activity_log table"
      via: "INSERT in update_project, assign_member, remove_member"
      pattern: "project_activity_log"
    - from: "server/api/projects/routes.py"
      to: "ftth_mufovi, ftth_stubovi, ftth_kablovi_podzemni, ftth_kablovi_nadzemni"
      via: "UNION ALL count query in stats endpoint"
      pattern: "UNION ALL"
---

<objective>
Add backend API endpoints for project stats and activity feed.

Purpose: Provide the data layer that the frontend dashboard will consume -- element counts (closures, poles, cables, cable length), team size, last sync timestamp, and a paginated activity feed combining sync uploads, member assignments, and status changes.
Output: Two new API endpoints (GET /projects/{id}/stats, GET /projects/{id}/activity), a new project_activity_log table, and activity logging wired into existing update/assign/remove endpoints.
</objective>

<execution_context>
@/home/rosen/.claude/get-shit-done/workflows/execute-plan.md
@/home/rosen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-dashboard-analytics/04-RESEARCH.md

@server/db/init.sql
@server/api/projects/routes.py
@server/api/projects/models.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project_activity_log table and Pydantic models for stats/activity</name>
  <files>server/db/init.sql, server/api/projects/models.py</files>
  <action>
1. In server/db/init.sql, add a new section after the PROJECT STATUS + USER ASSIGNMENT block:

```sql
-- PROJECT ACTIVITY LOG (for dashboard feed)
CREATE TABLE IF NOT EXISTS project_activity_log (
    id SERIAL PRIMARY KEY,
    project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    event_type TEXT NOT NULL,  -- 'status_change', 'member_removed'
    user_sub TEXT NOT NULL,
    details JSONB DEFAULT '{}'::jsonb,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS idx_pal_project ON project_activity_log (project_id, created_at DESC);
GRANT ALL PRIVILEGES ON TABLE project_activity_log TO fiberq;
GRANT USAGE, SELECT ON SEQUENCE project_activity_log_id_seq TO fiberq;
```

2. In server/api/projects/models.py, add these Pydantic models:

```python
class ProjectStats(BaseModel):
    closures: int | None
    poles: int | None
    cables: int | None
    cable_length_m: float | None
    team_size: int
    last_sync_at: datetime | None
    last_sync_features: int | None

class ActivityEntry(BaseModel):
    event_type: str
    event_at: datetime
    user_sub: str | None
    user_display_name: str | None
    details: dict | None

class ActivityPage(BaseModel):
    entries: list[ActivityEntry]
    has_more: bool
```
  </action>
  <verify>Run `python -c "from projects.models import ProjectStats, ActivityEntry, ActivityPage; print('OK')"` from the server directory (or equivalent import check). Verify init.sql parses correctly by checking syntax.</verify>
  <done>project_activity_log table defined in init.sql with index and grants. ProjectStats, ActivityEntry, ActivityPage models importable from projects.models.</done>
</task>

<task type="auto">
  <name>Task 2: Add stats endpoint, activity endpoint, and activity logging in existing mutations</name>
  <files>server/api/projects/routes.py</files>
  <action>
Add the following to server/api/projects/routes.py:

**A) Import the new models** at the top alongside existing imports from projects.models: ProjectStats, ActivityEntry, ActivityPage.

**B) Add GET /{project_id}/stats endpoint** (place BEFORE the existing GET /{project_id} detail endpoint to avoid route shadowing):

```python
@router.get("/{project_id}/stats", response_model=ProjectStats)
async def get_project_stats(
    project_id: int,
    user: UserInfo = Depends(get_current_user),
):
```

Implementation:
- Verify project exists (404 if not)
- Check visibility permission (same as get_project: admin/PM see all, others must be assigned)
- Run a single UNION ALL query to count elements across ftth_mufovi, ftth_stubovi, ftth_kablovi_podzemni, ftth_kablovi_nadzemni (as in the research SQL example). Include SUM of total_len_m for cable length.
- Determine `has_data`: check if at least one sync_log entry exists for this project (WHERE project_id = $1 AND status = 'completed'). If no completed sync, return null for all count metrics. If completed sync exists, return actual counts (including 0).
- Query team size from project_users COUNT.
- Query last sync from sync_log (most recent completed, ORDER BY completed_at DESC LIMIT 1) to get completed_at and features_uploaded.
- Return ProjectStats with null values when has_data is false, actual counts when true. team_size is always a number (never null). last_sync_at is null if no sync_log entry.

**C) Add GET /{project_id}/activity endpoint** (place after stats):

```python
@router.get("/{project_id}/activity", response_model=ActivityPage)
async def get_project_activity(
    project_id: int,
    limit: int = 20,
    before: str | None = None,
    user: UserInfo = Depends(get_current_user),
):
```

Implementation:
- Same project existence + visibility checks.
- Build a UNION ALL query combining three sources (each aliased to event_type, event_at, user_sub, user_display_name, details):
  1. sync_log: event_type='sync_upload', event_at=COALESCE(completed_at, started_at), join user_logins for display name, details={features_uploaded, sync_type}
  2. project_users: event_type='member_assigned', event_at=assigned_at, user_sub=assigned_by_sub (who assigned, not who was assigned), user_display_name from the row, details={member_name: user_display_name, project_role}
  3. project_activity_log: event_type from table, event_at=created_at, join user_logins for display name, details from table
- Add WHERE before clause if `before` param provided (event_at < $2), ORDER BY event_at DESC, LIMIT limit+1.
- Return has_more=true if rows > limit, entries=rows[:limit].
- Use `before` as ISO timestamp string parsed to datetime for cursor pagination.

**D) Wire activity logging into existing endpoints:**

In `update_project`: After the UPDATE succeeds, if `body.status` was provided (meaning status changed), INSERT into project_activity_log with event_type='status_change', details={'old_status': <fetch old status before update>, 'new_status': body.status}. To get old_status, fetch it BEFORE the update query runs.

In `remove_member`: Before the DELETE, fetch the member row to get user_display_name and project_role. After successful delete, INSERT into project_activity_log with event_type='member_removed', details={'member_name': display_name, 'project_role': role}.

In `assign_member`: After the INSERT/UPSERT succeeds, INSERT into project_activity_log with event_type='member_assigned', details={'member_name': body.user_display_name, 'project_role': body.project_role}. NOTE: Since assign events are already captured by querying project_users in the activity feed UNION, the activity_log entry for assignments is optional. Skip it to avoid duplicate events in the feed. Only log to project_activity_log for events NOT capturable from existing tables (status_change, member_removed).

IMPORTANT route ordering: FastAPI matches routes in definition order. The `/{project_id}/stats` and `/{project_id}/activity` endpoints MUST be defined BEFORE the `/{project_id}` detail endpoint, otherwise "stats" and "activity" will be interpreted as project_id values. Move the stats and activity endpoints above the existing GET /{project_id} route.
  </action>
  <verify>
Start the FastAPI server and test:
1. `curl -H "Authorization: Bearer $TOKEN" http://localhost:8000/projects/1/stats` returns JSON with closures, poles, cables, cable_length_m, team_size, last_sync_at, last_sync_features fields
2. `curl -H "Authorization: Bearer $TOKEN" http://localhost:8000/projects/1/activity?limit=5` returns JSON with entries array and has_more boolean
3. Verify that updating a project status via PUT /projects/1 with {"status": "in_progress"} creates an entry in project_activity_log

If direct curl testing is not feasible (auth token needed), verify by: reading the code for correctness, checking Python syntax with `python -c "import projects.routes"`, and confirming no import errors.
  </verify>
  <done>GET /projects/{id}/stats returns element counts (null when no sync data, 0+ when synced), team_size, last_sync_at, last_sync_features. GET /projects/{id}/activity returns paginated entries with has_more flag. Status changes logged to project_activity_log on update. Member removals logged to project_activity_log on delete.</done>
</task>

</tasks>

<verification>
- Both new endpoints return valid JSON matching their Pydantic response models
- Stats endpoint returns null counts for a project with no sync_log entries, actual counts for synced projects
- Activity endpoint pagination works: limit=5 returns 5 entries with has_more=true if more exist
- project_activity_log table created with proper FK, index, and grants
- Route ordering prevents "stats"/"activity" being parsed as project_id
</verification>

<success_criteria>
- GET /projects/{id}/stats and GET /projects/{id}/activity are functional and return correct data
- Existing update_project and remove_member endpoints log to project_activity_log
- No regressions in existing project CRUD endpoints
</success_criteria>

<output>
After completion, create `.planning/phases/04-dashboard-analytics/04-01-SUMMARY.md`
</output>
