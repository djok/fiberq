---
phase: 03-project-management-assignment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/db/init.sql
  - server/api/projects/models.py
  - server/api/projects/routes.py
  - server/api/auth/roles.py
autonomous: true

must_haves:
  truths:
    - "GET /projects returns only assigned projects for non-admin/non-PM users, all projects for admin/PM, with member_names list per project"
    - "POST /projects creates a project with name, description, and status (defaults to planning)"
    - "PUT /projects/{id} can update name, description, and status"
    - "POST /projects/{id}/members assigns a user to a project with a project-level role"
    - "DELETE /projects/{id}/members/{member_id} removes a user from a project"
    - "GET /projects/{id} returns project detail with members list and computed PostGIS extent"
    - "Assigning an invalid project role (not manager/specialist/observer) returns HTTP 400"
  artifacts:
    - path: "server/db/init.sql"
      provides: "project_users table and status column on projects"
      contains: "CREATE TABLE IF NOT EXISTS project_users"
    - path: "server/api/projects/models.py"
      provides: "Pydantic models for project CRUD with status, members, member_names, extent"
      contains: "ProjectMemberOut"
    - path: "server/api/projects/routes.py"
      provides: "Role-scoped list, detail with members/extent, assignment endpoints"
      contains: "project_users"
    - path: "server/api/auth/roles.py"
      provides: "require_project_manager_or_admin role dependency"
      contains: "project_manager"
  key_links:
    - from: "server/api/projects/routes.py"
      to: "server/db/init.sql"
      via: "SQL queries on project_users table"
      pattern: "project_users"
    - from: "server/api/projects/routes.py"
      to: "server/api/auth/roles.py"
      via: "Depends(require_project_manager_or_admin)"
      pattern: "require_project_manager_or_admin"
---

<objective>
Extend the backend with project status, user-to-project assignment via a junction table, role-scoped project listing, PostGIS extent computation, and assignment CRUD endpoints.

Purpose: The frontend needs a complete project API with visibility scoping, member management, and geographic extent data before any UI work can begin.
Output: Updated DB schema with project_users table and status column; extended FastAPI routes with 6+ endpoints covering project CRUD, assignment, and extent.
</objective>

<execution_context>
@/home/rosen/.claude/get-shit-done/workflows/execute-plan.md
@/home/rosen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-project-management-assignment/03-RESEARCH.md
@server/api/projects/routes.py
@server/api/projects/models.py
@server/api/auth/roles.py
@server/api/auth/models.py
@server/db/init.sql
@server/api/main.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project_users table and status column to database schema + update Pydantic models</name>
  <files>
    server/db/init.sql
    server/api/projects/models.py
    server/api/auth/roles.py
  </files>
  <action>
1. **server/db/init.sql** -- Add two schema changes AFTER the existing projects table definition (append to file, do NOT modify existing tables inline since init.sql runs on first deployment only):

```sql
-- Add status column to projects table
ALTER TABLE projects ADD COLUMN IF NOT EXISTS status TEXT NOT NULL DEFAULT 'planning';

-- Project-user assignment junction table
CREATE TABLE IF NOT EXISTS project_users (
    id SERIAL PRIMARY KEY,
    project_id INTEGER NOT NULL REFERENCES projects(id) ON DELETE CASCADE,
    user_sub TEXT NOT NULL,
    user_display_name TEXT,
    user_email TEXT,
    project_role TEXT NOT NULL DEFAULT 'specialist'
        CHECK (project_role IN ('manager', 'specialist', 'observer')),
    assigned_at TIMESTAMPTZ DEFAULT NOW(),
    assigned_by_sub TEXT,
    UNIQUE (project_id, user_sub)
);
CREATE INDEX IF NOT EXISTS idx_project_users_project ON project_users (project_id);
CREATE INDEX IF NOT EXISTS idx_project_users_user ON project_users (user_sub);
```

Place these after the existing `user_logins` table block at the end of init.sql. Also add grants for fiberq user (same pattern as existing grants).

2. **server/api/projects/models.py** -- Replace with extended models:

- `ProjectCreate`: add `status: str = "planning"` field
- `ProjectUpdate`: add `status: str | None = None` field
- `ProjectOut`: add `status: str`, `member_count: int = 0`, `member_names: list[str] = []`, `extent: dict | None = None` fields. The `member_names` field returns display names (or user_sub fallback) of assigned users, enabling client-side filtering by assigned user.
- Add `ProjectDetailOut(BaseModel)`: id, name, description, status, created_at, created_by_sub, members (list[ProjectMemberOut]), extent (dict | None)
- Add `ProjectMemberOut(BaseModel)`: id, user_sub, user_display_name (str | None), user_email (str | None), project_role, assigned_at
- Add `AssignMemberBody(BaseModel)`: user_sub, user_display_name (str | None = None), user_email (str | None = None), project_role (str = "specialist")
- Add constant: `PROJECT_STATUSES = ["planning", "in_progress", "completed", "paused", "archived"]`
- Add constant: `PROJECT_ROLES = ["manager", "specialist", "observer"]`

3. **server/api/auth/roles.py** -- Add new role dependency:

```python
require_project_manager_or_admin = require_role("admin", "project_manager")
```

This is the global role check for project creation. Assignment permission (project-level manager) is checked in the route handler itself since it requires a DB lookup.
  </action>
  <verify>
Check that init.sql has valid SQL syntax: `python3 -c "open('server/db/init.sql').read()"` (reads without error).
Check models.py imports and class definitions: `python3 -c "import sys; sys.path.insert(0, 'server/api'); from projects.models import ProjectCreate, ProjectUpdate, ProjectOut, ProjectDetailOut, ProjectMemberOut, AssignMemberBody, PROJECT_STATUSES, PROJECT_ROLES; print('Models OK')"`.
Check roles.py: `python3 -c "import sys; sys.path.insert(0, 'server/api'); from auth.roles import require_project_manager_or_admin; print('Roles OK')"`.
  </verify>
  <done>
init.sql contains project_users CREATE TABLE with CHECK constraint and indexes. models.py exports all 6 models and 2 constants. roles.py exports require_project_manager_or_admin.
  </done>
</task>

<task type="auto">
  <name>Task 2: Extend project routes with role-scoped listing, detail with members/extent, and assignment CRUD</name>
  <files>
    server/api/projects/routes.py
  </files>
  <action>
Rewrite `server/api/projects/routes.py` to include all project and assignment endpoints. Keep the existing router pattern but extend significantly:

**Imports to add:** `logging`, `PROJECT_STATUSES`, `PROJECT_ROLES`, `ProjectDetailOut`, `ProjectMemberOut`, `AssignMemberBody`, `require_project_manager_or_admin` from auth.roles.

**Endpoints to implement:**

1. **GET /** (list_projects) -- MODIFY existing endpoint:
   - If user.is_admin or "project_manager" in user.roles: SELECT all projects
   - Otherwise: SELECT only projects joined via project_users WHERE user_sub = user.sub
   - Both queries must include: `(SELECT COUNT(*) FROM project_users pu WHERE pu.project_id = p.id) as member_count`
   - Both queries must include the `status` column
   - After fetching projects, batch-fetch member names: `SELECT project_id, COALESCE(user_display_name, user_sub) as name FROM project_users WHERE project_id = ANY($1)` (pass list of project IDs). Build a `member_names_map: dict[int, list[str]]` keyed by project_id. Attach `member_names` list to each ProjectOut.
   - Batch-compute extents using a single UNION ALL query across all infrastructure tables (ftth_okna, ftth_stubovi, ftth_kablovi_podzemni, ftth_kablovi_nadzemni, ftth_trase, ftth_cevi, ftth_mufovi, ftth_spojevi, ftth_elements), grouped by project_id. Use `ST_AsGeoJSON(ST_Envelope(ST_Extent(geom)))::json`. Build an extent_map dict and attach to each project. Fall back to project's own bounds_geom if no features.
   - Return `list[ProjectOut]`

2. **POST /** (create_project) -- MODIFY existing:
   - Change dependency from `require_engineer_or_admin` to `require_project_manager_or_admin`
   - Add status field to INSERT (validate against PROJECT_STATUSES, raise 400 if invalid)
   - Include status in RETURNING clause

3. **GET /{project_id}** (get_project) -- MODIFY to return ProjectDetailOut:
   - Fetch project row (include status)
   - Check visibility: if user is NOT admin/project_manager AND not assigned to project, raise 403
   - Fetch members from project_users WHERE project_id
   - Compute extent: single UNION ALL query across all infrastructure tables for this project_id, using ST_AsGeoJSON(ST_Envelope(ST_Extent(geom))). Fall back to bounds_geom.
   - Return ProjectDetailOut with members list and extent

4. **PUT /{project_id}** (update_project) -- MODIFY existing:
   - Add status to updateable fields (validate against PROJECT_STATUSES)
   - Change dependency to check: admin OR project_manager (global) OR manager role in this project (DB lookup)
   - Include status in RETURNING

5. **DELETE /{project_id}** (delete_project) -- Keep mostly as-is but change dependency to `require_project_manager_or_admin`

6. **POST /{project_id}/members** (assign_member) -- NEW:
   - Body: AssignMemberBody (user_sub, user_display_name, user_email, project_role)
   - Permission: admin OR user has project_role='manager' in this project (DB lookup, raise 403 if neither)
   - Validate project_role against PROJECT_ROLES (raise 400 if invalid)
   - INSERT INTO project_users with ON CONFLICT (project_id, user_sub) DO UPDATE SET project_role, user_display_name, user_email, assigned_by_sub (upsert pattern for re-assigning with different role)
   - Return 201 with the created/updated member row as ProjectMemberOut

7. **DELETE /{project_id}/members/{member_id}** (remove_member) -- NEW:
   - Permission: admin OR user has project_role='manager' in this project
   - DELETE FROM project_users WHERE id = member_id AND project_id = project_id
   - Return 204

8. **GET /{project_id}/assignable-users** (list_assignable_users) -- NEW:
   - Permission: admin OR user has project_role='manager' in this project
   - This endpoint returns users from the existing `/users` list endpoint. Call the user listing logic or query user_logins for known users. Since users are in Kanidm (not local DB), and the users router already has a list endpoint, the simplest approach: import from `users.routes` or replicate a minimal query. Best approach: query user_logins table for known users (user_sub, username) and return those as minimal objects. This is a pragmatic shortcut -- user_logins contains all users who have ever logged in.
   - Return: list of `{ user_sub: str, display_name: str | None, email: str | None }`

**Helper function to add:**

```python
async def _check_project_manager_permission(project_id: int, user: UserInfo):
    """Check if user is admin or has manager role in this project. Raises 403 if not."""
    if user.is_admin:
        return
    if "project_manager" in user.roles:
        return
    pool = get_pool()
    row = await pool.fetchrow(
        "SELECT project_role FROM project_users WHERE project_id = $1 AND user_sub = $2",
        project_id, user.sub
    )
    if not row or row["project_role"] != "manager":
        raise HTTPException(status_code=403, detail="Project manager role required")
```

Use this helper in assign_member, remove_member, update_project, and assignable-users endpoints.

**Important:** Keep the existing patterns -- use `get_pool()`, `pool.fetch/fetchrow`, return Pydantic model instances. Add `import logging` and create logger at module level: `logger = logging.getLogger("fiberq.projects")`.
  </action>
  <verify>
Run Python syntax check: `python3 -c "import ast; ast.parse(open('server/api/projects/routes.py').read()); print('Syntax OK')"`.
Verify all imports resolve: `cd /home/rosen/fiberq/server/api && python3 -c "from projects.routes import router; print(f'Router with {len(router.routes)} routes')"` (should show 8+ routes).
  </verify>
  <done>
routes.py has 8 endpoints: list (role-scoped), create (PM/admin), get (detail with members + extent), update (with status), delete, assign member, remove member, and list assignable users. Role-scoped visibility works: admin/PM see all, others see only assigned. PostGIS extent computed via batch UNION ALL query. Permission helper checks admin OR global PM OR project-level manager.
  </done>
</task>

</tasks>

<verification>
1. `python3 -c "import ast; ast.parse(open('server/api/projects/routes.py').read()); print('OK')"` -- syntax valid
2. `python3 -c "import ast; ast.parse(open('server/api/projects/models.py').read()); print('OK')"` -- syntax valid
3. `grep -c 'project_users' server/db/init.sql` -- at least 3 (CREATE TABLE, 2 indexes)
4. `grep 'project_role' server/api/projects/models.py` -- present in AssignMemberBody and ProjectMemberOut
5. `grep 'ST_Extent' server/api/projects/routes.py` -- present (PostGIS extent computation)
6. `grep 'require_project_manager_or_admin' server/api/auth/roles.py` -- present
</verification>

<success_criteria>
Backend API fully supports: role-scoped project listing, project CRUD with status field, user-to-project assignment with project-level roles (manager/specialist/observer), member removal, PostGIS extent computation, and assignable users list. All endpoints use proper permission checks (admin, global PM, or project-level manager).
</success_criteria>

<output>
After completion, create `.planning/phases/03-project-management-assignment/03-01-SUMMARY.md`
</output>
