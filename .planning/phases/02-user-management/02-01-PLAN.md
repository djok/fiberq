---
phase: 02-user-management
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - server/api/users/__init__.py
  - server/api/users/kanidm_client.py
  - server/api/users/models.py
  - server/api/users/routes.py
  - server/api/config.py
  - server/api/main.py
  - server/api/auth/routes.py
  - server/db/init.sql
autonomous: true

must_haves:
  truths:
    - "GET /api/users returns a list of all Kanidm persons with name, email, roles, active status, and last login"
    - "POST /api/users creates a person in Kanidm, assigns groups, and returns a credential reset token"
    - "POST /api/users/{id}/deactivate sets account_expire to epoch, POST /api/users/{id}/reactivate clears it"
    - "PUT /api/users/{id}/roles replaces group memberships for the fiberq_* groups"
    - "POST /api/users/{id}/reset-password returns a credential reset token"
    - "Each WebUI login records last_login_at in the user_logins table"
  artifacts:
    - path: "server/api/users/kanidm_client.py"
      provides: "Kanidm REST API client using service account token"
      min_lines: 80
    - path: "server/api/users/routes.py"
      provides: "FastAPI /users router with all CRUD endpoints"
      exports: ["router"]
    - path: "server/api/users/models.py"
      provides: "Pydantic models for user CRUD"
      contains: "class UserCreate"
    - path: "server/db/init.sql"
      provides: "user_logins table for last login tracking"
      contains: "CREATE TABLE user_logins"
  key_links:
    - from: "server/api/users/routes.py"
      to: "server/api/users/kanidm_client.py"
      via: "KanidmAdminClient instance"
      pattern: "kanidm\\."
    - from: "server/api/users/routes.py"
      to: "server/api/auth/roles.py"
      via: "require_admin dependency"
      pattern: "Depends\\(require_admin\\)"
    - from: "server/api/main.py"
      to: "server/api/users/routes.py"
      via: "include_router"
      pattern: "include_router.*users"
    - from: "server/api/auth/routes.py"
      to: "server/db/init.sql"
      via: "INSERT INTO user_logins on login"
      pattern: "user_logins"
---

<objective>
Build the FastAPI backend for user management: a Kanidm admin API client, Pydantic models, FastAPI /users router with all CRUD endpoints (list, create, deactivate/reactivate, role change, password reset), and last login tracking in PostgreSQL.

Purpose: The WebUI frontend needs a backend proxy to manage users in Kanidm. The logged-in user's OIDC token cannot call Kanidm's admin API directly -- a service account API token is required. This plan creates that proxy layer.

Output: Working /api/users/* endpoints that the Next.js frontend (Plan 02/03) will call via Server Actions.
</objective>

<execution_context>
@/home/rosen/.claude/get-shit-done/workflows/execute-plan.md
@/home/rosen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-user-management/02-RESEARCH.md
@.planning/phases/02-user-management/02-CONTEXT.md
@server/api/config.py
@server/api/main.py
@server/api/database.py
@server/api/dependencies.py
@server/api/auth/kanidm.py
@server/api/auth/models.py
@server/api/auth/roles.py
@server/db/init.sql
</context>

<tasks>

<task type="auto">
  <name>Task 1: Kanidm admin client and Pydantic models</name>
  <files>
    server/api/users/__init__.py
    server/api/users/kanidm_client.py
    server/api/users/models.py
    server/api/config.py
  </files>
  <action>
    **1. Create `server/api/users/__init__.py`** -- empty file.

    **2. Create `server/api/users/kanidm_client.py`** -- async Kanidm REST API client class:

    Class `KanidmAdminClient` with constructor taking `base_url`, `token`, `verify_tls` from settings:
    - Import `httpx`, `logging`, `config.settings`
    - Use `httpx.AsyncClient(verify=self.verify_tls)` for all calls
    - All methods are `async`
    - `Authorization: Bearer {self.token}` header on all requests
    - `Content-Type: application/json` header on mutations

    Methods to implement:
    - `list_persons() -> list[dict]`: GET /v1/person, returns JSON list
    - `get_person(id: str) -> dict`: GET /v1/person/{id}, returns JSON
    - `create_person(username: str, display_name: str) -> None`: POST /v1/person with ProtoEntry body `{"attrs": {"name": [username], "displayname": [display_name]}}`
    - `set_person_attr(id: str, attr: str, values: list[str]) -> None`: PUT /v1/person/{id}/_attr/{attr} with JSON body `values`
    - `delete_person_attr(id: str, attr: str) -> None`: DELETE /v1/person/{id}/_attr/{attr}
    - `deactivate_person(id: str) -> None`: calls set_person_attr(id, "account_expire", ["1970-01-01T00:00:00+00:00"])
    - `reactivate_person(id: str) -> None`: calls delete_person_attr(id, "account_expire")
    - `create_credential_reset_token(id: str, ttl: int = 3600) -> str`: GET /v1/person/{id}/_credential/_update_intent/{ttl}, returns the token string from response
    - `get_group_members(group_name: str) -> list[str]`: GET /v1/group/{group_name}/_attr/member, returns member list
    - `add_group_member(group_name: str, member_id: str) -> None`: POST /v1/group/{group_name}/_attr/member with body `[member_id]`
    - `set_group_members(group_name: str, members: list[str]) -> None`: PUT /v1/group/{group_name}/_attr/member with body `members`
    - `remove_group_member(group_name: str, member_id: str) -> None`: GET current members, filter out member_id, PUT remaining list. If list is empty after removal, DELETE the member attribute.

    Error handling: Let httpx.HTTPStatusError propagate -- routes.py will catch and convert to HTTPException.

    **3. Create `server/api/users/models.py`** -- Pydantic models:

    ```python
    from pydantic import BaseModel
    from datetime import datetime

    class UserCreate(BaseModel):
        username: str
        display_name: str
        email: str
        phone: str | None = None
        roles: list[str]  # e.g., ["admin", "project_manager"]

    class UserRoleUpdate(BaseModel):
        roles: list[str]  # Full replacement list

    class UserOut(BaseModel):
        id: str  # Kanidm UUID
        username: str
        display_name: str
        email: str
        phone: str | None = None
        roles: list[str]
        is_active: bool
        last_login: datetime | None = None

    class UserListOut(BaseModel):
        users: list[UserOut]

    class CredentialResetOut(BaseModel):
        token: str
        ttl: int
        reset_url: str  # {kanidm_url}/ui/reset
    ```

    **4. Update `server/api/config.py`** -- add `kanidm_api_token: str = ""` field to the Settings class. This is the service account read-write API token for Kanidm admin operations. Do NOT remove or change any existing fields.
  </action>
  <verify>
    python -c "import sys; sys.path.insert(0, 'server/api'); from users.kanidm_client import KanidmAdminClient; from users.models import UserCreate, UserOut, UserListOut, UserRoleUpdate, CredentialResetOut; print('OK')"
  </verify>
  <done>KanidmAdminClient class has all 12 methods. Pydantic models for UserCreate, UserRoleUpdate, UserOut, UserListOut, CredentialResetOut exist. config.py has kanidm_api_token field.</done>
</task>

<task type="auto">
  <name>Task 2: FastAPI /users router with all CRUD endpoints</name>
  <files>
    server/api/users/routes.py
    server/api/main.py
  </files>
  <action>
    **1. Create `server/api/users/routes.py`** -- FastAPI router with all user management endpoints:

    ```python
    from fastapi import APIRouter, Depends, HTTPException
    import httpx
    import logging

    from auth.kanidm import get_current_user
    from auth.models import UserInfo
    from auth.roles import require_admin
    from database import get_pool
    from config import settings
    from users.models import UserCreate, UserOut, UserListOut, UserRoleUpdate, CredentialResetOut
    from users.kanidm_client import KanidmAdminClient

    logger = logging.getLogger("fiberq.users")
    router = APIRouter()
    ```

    Create a module-level `_get_kanidm_client()` function that returns a `KanidmAdminClient` instance. This can be a simple factory or singleton.

    The 4 FiberQ role groups are: `fiberq_admin`, `fiberq_project_manager`, `fiberq_engineer`, `fiberq_field_worker`. Define `FIBERQ_ROLE_GROUPS` constant mapping role names to group names.

    Helper function `_parse_person(person: dict, login_map: dict) -> UserOut`:
    - Extract attrs from person dict: `attrs = person.get("attrs", {})`
    - Get uuid: `attrs.get("uuid", [None])[0]` or `attrs.get("name", [""])[0]` as fallback id
    - Get username: `attrs.get("name", [""])[0]`
    - Get display_name: `attrs.get("displayname", [""])[0]`
    - Get email: `attrs.get("mail", [""])[0]`
    - Get phone: `attrs.get("phone", [None])[0]` (may not exist)
    - Determine is_active: `"account_expire" not in attrs`
    - Extract roles from `attrs.get("memberof", [])`: filter strings starting with "fiberq_", strip prefix
    - Get last_login from login_map by uuid or username
    - Return UserOut instance

    **Endpoints:**

    **GET ""** (list_users): `user: UserInfo = Depends(require_admin)`
    - Call kanidm.list_persons()
    - Fetch last logins from DB: `SELECT user_sub, last_login_at FROM user_logins`
    - Build login_map dict
    - Parse each person through _parse_person
    - Filter out service accounts: skip persons whose username starts with "admin@" or is "anonymous" or whose `attrs` contains `"class"` with value `"service_account"`
    - Return UserListOut

    **GET "/{user_id}"** (get_user): `Depends(require_admin)`
    - Call kanidm.get_person(user_id)
    - Fetch last login for this user
    - Parse and return single UserOut

    **POST ""** (create_user): `body: UserCreate, Depends(require_admin)`, status_code=201
    - Wrap in try/except httpx.HTTPStatusError
    - Call kanidm.create_person(body.username, body.display_name)
    - If body.email: kanidm.set_person_attr(body.username, "mail", [body.email])
    - If body.phone: kanidm.set_person_attr(body.username, "phone", [body.phone])
    - For each role in body.roles: kanidm.add_group_member(f"fiberq_{role}", body.username)
    - Generate credential reset token: kanidm.create_credential_reset_token(body.username, 3600)
    - On 409 Conflict from Kanidm: raise HTTPException(409, "Username already exists")
    - On other httpx errors: raise HTTPException(502, f"Identity service error: {e}")
    - Return CredentialResetOut with token, ttl=3600, reset_url=f"{settings.kanidm_url}/ui/reset"

    **POST "/{user_id}/deactivate"** (deactivate_user): `Depends(require_admin)`
    - Call kanidm.deactivate_person(user_id)
    - Return {"status": "deactivated"}
    - Handle httpx errors -> HTTPException

    **POST "/{user_id}/reactivate"** (reactivate_user): `Depends(require_admin)`
    - Call kanidm.reactivate_person(user_id)
    - Return {"status": "reactivated"}

    **PUT "/{user_id}/roles"** (update_roles): `body: UserRoleUpdate, Depends(require_admin)`
    - For each fiberq_* group in FIBERQ_ROLE_GROUPS:
      - If role is in body.roles: add_group_member(group, user_id)
      - If role is NOT in body.roles: remove_group_member(group, user_id) (wrapped in try/except to ignore "not a member" errors)
    - Return {"status": "roles_updated", "roles": body.roles}

    **POST "/{user_id}/reset-password"** (reset_password): `Depends(require_admin)`
    - Call kanidm.create_credential_reset_token(user_id, 3600)
    - Return CredentialResetOut with token, ttl=3600, reset_url=f"{settings.kanidm_url}/ui/reset"

    **2. Update `server/api/main.py`** -- register the users router:
    - Add import: `from users.routes import router as users_router`
    - Add: `app.include_router(users_router, prefix="/users", tags=["users"])`
    - Place it after the auth_router registration
  </action>
  <verify>
    python -c "import sys; sys.path.insert(0, 'server/api'); from users.routes import router; print(f'Routes: {len(router.routes)}'); assert len(router.routes) >= 7, 'Expected at least 7 routes'"
  </verify>
  <done>FastAPI /users router registered in main.py with 7 endpoints: list, get, create, deactivate, reactivate, update roles, reset password. All endpoints require admin role.</done>
</task>

<task type="auto">
  <name>Task 3: Last login tracking in PostgreSQL</name>
  <files>
    server/db/init.sql
    server/api/auth/routes.py
  </files>
  <action>
    **1. Update `server/db/init.sql`** -- add user_logins table at the end of the file (before any closing comments):

    ```sql
    -- =============================================================================
    -- USER LOGIN TRACKING
    -- =============================================================================
    -- Tracks last login time per user since Kanidm does not expose this via API.
    -- Updated on each WebUI or QGIS plugin authentication.

    CREATE TABLE IF NOT EXISTS user_logins (
        user_sub TEXT PRIMARY KEY,
        username TEXT,
        last_login_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        login_source TEXT DEFAULT 'web'
    );
    CREATE INDEX IF NOT EXISTS idx_user_logins_last ON user_logins (last_login_at);
    ```

    Do NOT modify any existing tables or statements in init.sql. Only APPEND this new section.

    **2. Update `server/api/auth/routes.py`** -- add a POST /auth/record-login endpoint:

    Read the existing file first. Add a new endpoint that records login events:

    ```python
    @router.post("/record-login")
    async def record_login(user: UserInfo = Depends(get_current_user)):
        """Record a login event for the authenticated user."""
        pool = get_pool()
        await pool.execute("""
            INSERT INTO user_logins (user_sub, username, last_login_at, login_source)
            VALUES ($1, $2, NOW(), 'web')
            ON CONFLICT (user_sub) DO UPDATE
            SET last_login_at = NOW(), login_source = 'web', username = $2
        """, user.sub, user.name)
        return {"status": "recorded"}
    ```

    Import `get_pool` from `database` if not already imported. This endpoint will be called by the Next.js auth callback (jwt callback on sign-in) to track when users log in.

    Also update the existing GET /auth/me endpoint (if it exists) or the token validation flow to record login -- check auth/routes.py for the current structure and add login recording at the appropriate point.
  </action>
  <verify>
    grep -q "user_logins" server/db/init.sql && echo "Table found in init.sql"
    python -c "import sys; sys.path.insert(0, 'server/api'); from auth.routes import router; print(f'Auth routes: {len(router.routes)}')"
  </verify>
  <done>user_logins table defined in init.sql. POST /auth/record-login endpoint exists and records user_sub, username, last_login_at, login_source with upsert logic.</done>
</task>

</tasks>

<verification>
1. All files import correctly: `python -c "import sys; sys.path.insert(0, 'server/api'); from main import app; print('App loaded')"` (must not crash)
2. Users router has 7 endpoints registered
3. config.py has kanidm_api_token field
4. init.sql has user_logins CREATE TABLE
5. auth/routes.py has record-login endpoint
</verification>

<success_criteria>
- FastAPI /users/* endpoints exist for: list, get, create, deactivate, reactivate, update-roles, reset-password
- All endpoints are admin-only (require_admin dependency)
- KanidmAdminClient handles all Kanidm REST API operations with proper error handling
- user_logins table tracks last login timestamps
- POST /auth/record-login records login events from the WebUI
- Code follows existing codebase conventions (snake_case, logger per module, Pydantic models with *Create/*Out suffixes)
</success_criteria>

<output>
After completion, create `.planning/phases/02-user-management/02-01-SUMMARY.md`
</output>
